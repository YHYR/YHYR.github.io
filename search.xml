<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>基于Python初探Linux下的僵尸进程和孤儿进程</title>
      <link href="/2018/06/02/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p><em>通过对比子父进程的执行周期来详细讨论僵尸进程产生的原因和规避方法</em></p><a id="more"></a><p>样例代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, main_process_time, child_process_time)</span>:</span></span><br><span class="line">        self.main_process_time = main_process_time</span><br><span class="line">        self.child_process_time = child_process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excutor</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'main process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        p = ChildProcess(self.child_process_time)</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.main_process_time):</span><br><span class="line">            print(<span class="string">'main process, pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'main process end, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_time)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.process_time = process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'child process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.process_time):</span><br><span class="line">            print(<span class="string">'child process pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'child process end, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_process_time = <span class="number">5</span></span><br><span class="line">    child_process_time = <span class="number">10</span></span><br><span class="line">    action = MainProcess(main_process_time, child_process_time)</span><br><span class="line">    action.excutor()</span><br></pre></td></tr></table></figure><h1 id="业务场景及现象描述"><a href="#业务场景及现象描述" class="headerlink" title="业务场景及现象描述"></a>业务场景及现象描述</h1><h2 id="场景一：子进程的运行周期大于父进程"><a href="#场景一：子进程的运行周期大于父进程" class="headerlink" title="场景一：子进程的运行周期大于父进程"></a>场景一：子进程的运行周期大于父进程</h2><ul><li><p>子进程不调用join()方法：无僵尸进程存在</p><p>代码执行逻辑</p><p>　　父进程执行到p.start()后，子父进程开始同时执行；当父进程结束后，子进程继续执行；此时父进程并不退出依然存在，且进程状态依然为休眠状态(S+)；当子进程结束后，子父进程同时销毁。打印结果如下图所示：</p><p><img src="./子进程运行周期长，且不调用join.png" alt="子进程运行周期长，且不调用join"></p></li><li><p>子进程调用join()方法：无僵尸进程存在</p><p>代码执行逻辑</p><ol><li><p>join()方法不带参数：首先启动父进程，当执行到p.start()后，子进程开始执行，此时父进程处于挂起状态；当子进程结束后，父进程开始继续执行后续代码。打印结果如下图所示：</p><p><img src="./子进程运行周期长，调用无参join.png" alt="子进程运行周期长，调用无参join"></p></li><li><p>join()方法带参数【eg：p.join(3)】：首先启动父进程，当执行到p.start()后，子进程开始执行，且父进程开始挂起；当子进程执行三秒后，父进程被唤醒且子父进程开始同时执行；当父进程结束后，子进程继续执行，此时父进程并不退出依然存在，且进程状态依然为休眠状态(S+)；当子进程结束后，子父进程同时销毁。打印结果如下图所示：</p><p><img src="./子进程运行周期长，调用有参join.png" alt="子进程运行周期长，调用有参join"></p></li></ol></li></ul><h2 id="场景二：子进程运行周期小与父进程"><a href="#场景二：子进程运行周期小与父进程" class="headerlink" title="场景二：子进程运行周期小与父进程"></a>场景二：子进程运行周期小与父进程</h2><ul><li><p>子进程不调用join()方法：<font color="red">有僵尸进程存在</font></p><p>代码执行逻辑</p><p>　　首先启动父进程，当执行到p.start()后，子父进程开始同时执行；<font color="red">当子进程尚未结束时</font>，子父进程的打印结果及其进程状态如下图所示：</p><p><img src="./父进程运行周期长，不调用join，且子进程尚未结束.png" alt="父进程运行周期长，不调用join，且子进程尚未结束"></p><p><font color="red">当子进程结束，但父进程尚未结束时，子进程变为僵尸进程</font>，进程的打印结果和进程状态如下图所示：</p><p><img src="./父进程运行周期长，不调用join，且子进程已经结束.png" alt="父进程运行周期长，不调用join，且子进程已经结束"></p></li><li><p>子进程调用join()方法：无僵尸进程存在</p><p>代码执行逻辑</p><ol><li><p>join()方法不带参数：当父进程执行到p.start()后，子进程开始执行，且父进程挂起；当子进程尚未结束时，程序打印结果以及系统中进程状态如下图所示：</p><p><img src="/images/placeholder.png" alt="父进程运行周期长，调用无参join，且子进程尚未结束" data-src="./父进程运行周期长，调用无参join，且子进程尚未结束.png" class="lazyload"></p><p><font color="red">当子进程结束而父进程尚未结束时，子进程正常销毁</font>，此时只有父进程在继续运行;程序打印结果以及系统中进程状态如下图所示：</p><p><img src="/images/placeholder.png" alt="父进程运行周期长，调用无参join，且子进程已经结束" data-src="./父进程运行周期长，调用无参join，且子进程已经结束.png" class="lazyload"></p></li><li><p>join()方法带参数【eg：p.join(3)】：当父进程执行到p.start()后子进程开始执行，父进程开始挂起；子进程执行三秒后唤醒父进程，此时子父进程同时执行；当子进程结束后会正常退出，没有僵尸进程，与此同时父进程继续执行。</p><p><img src="/images/placeholder.png" alt="父进程运行周期长，调用有参join，且子进程已经结束" data-src="./父进程运行周期长，调用有参join，且子进程已经结束.png" class="lazyload"></p></li></ol></li></ul><h1 id="Linux进程基本概念"><a href="#Linux进程基本概念" class="headerlink" title="Linux进程基本概念"></a>Linux进程基本概念</h1><p>　　在Linux中，默认情况下当父进程创建完子进程后，子父进程的运行时相互独立的、异步的；即父进程无法感知到子进程何时结束。为了让父进程可以在任意时刻都能获取到子进程结束时的状态信息，提供了如下机制：</p><ul><li>1) 当子进程结束后，系统在释放该子进程的所有资源(eg：占用的内存、打开的文件等)，仍会保留一定的信息，包括进程号(process id)，进程的退出状态(the termination status of the process)，运行时间(the amount of CPU time taken by the process)等。</li><li>2) 当父进程调用wait/waitpid方法获取子进程的退出状态信息后，系统会彻底释放掉对应子进程的所有信息。如果父进程没有调用wait/waitpid方法，且父进程一直存活，则该子进程所有用的端口号信息一直保存，从而该子进程变为僵尸进程(对系统有害)；若父进程没有调用wait/waitpid方法，且父进程已经结束，则子进程会从僵尸进程转变为孤儿进程(对系统无害)。</li></ul><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>　　一个进程创建了一个子进程，且当该子进程结束后，父进程没有调用wait/waitpid方法来获取子进程的退出状态信息，那么该子进程将会一直保留在系统中，并持续占有该进程的端口号等信息；进程标识符为<code>&lt;defunct&gt;</code>，进程状态位为Z，这种进程称之为僵尸进程。如下图所示：</p><p><img src="/images/placeholder.png" alt="僵尸进程" data-src="./僵尸进程.png" class="lazyload"></p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>　　当父进程退出而子进程还在运行时，这些子进程将会变成孤儿进程。孤儿进程将会init进程统一管理。因为init进程的进程号为1，所以所有的孤儿进程的父进程号均为1；此外，因为init进程会主动收集所有子进程的退出状态信息，所有由init进程管理的子进程是不会变成僵尸进程。因此，孤儿进程是对系统无害的。</p><p>　　例如：在上述样例代码的基础上，将子父进程的运行周期均扩大为60(保证有足够的时间去手动kill掉父进程，方便举例验证)，当子父进程运行的同时，手动kill掉父进程，子进程的进程号变化如下图所示</p><p>kill前：</p><p><img src="/images/placeholder.png" alt="孤儿进程手动kill前" data-src="./孤儿进程手动kill前.png" class="lazyload"></p><p>kill后：</p><p><img src="/images/placeholder.png" alt="孤儿进程手动kill后" data-src="./孤儿进程手动kill后.png" class="lazyload"></p><h1 id="Python-multiprocessing的join-方法"><a href="#Python-multiprocessing的join-方法" class="headerlink" title="Python - multiprocessing的join()方法"></a>Python - multiprocessing的join()方法</h1><p>源码中该方法的描述如下所示：</p><p><img src="/images/placeholder.png" alt="join源码描述" data-src="./join源码描述.png" class="lazyload"></p><p>不难看出，该方法主要做两件事：</p><p>第一：通知父进程调用wait方法来获取子进程的结束状态信息，从而清除僵尸进程</p><p>第二：将该子进程从父进程的子进程列表中移除</p><p>因此，基于Python实现多进程时，可以通过join()方法来消除子进程转化为僵尸进程的潜在风险。</p><p>　　需要注意的是：join()方法的官方解释是“等待直到子进程终止”。需要注意的是这里<strong>等待的主语是父进程而非子进程</strong>。join()方法有一个timeout参数，用来设置等待时长。如果不设置，这意味着等子进程结束后，父进程才开始继续执行；如果设置timeout参数，当timeout小与子进程的运行周期时，表示当子进程执行timeout时长后(单位是秒)，父进程被唤醒然后子父进程同时执行；当timeout大于子进程的运行周期时，子进程结束后父进程立即执行，而不是等到timeout时长后才开始执行。</p><p>　　在写代码的时候，需要注意join()方法的使用；否则有可能会导致看似的多进程并发代码，实则的多进程的串行执行。Eg：将样例代码中的MainProcess类的excutor方法改写成如下形式：</p><p><img src="/images/placeholder.png" alt="join串行代码写法" data-src="./join串行代码写法.png" class="lazyload"></p><p>　　当基于for循环创建子进程时，若将p.join()卸载循环体内，则实际的执行逻辑为：主线程 =&gt; 子线程1 =&gt; 子线程2 =&gt; 子线程3 =&gt; 主线程；代码打印结果如下图所示：</p><p><img src="/images/placeholder.png" alt="join串行代码输出结果" data-src="./join串行代码输出结果.png" class="lazyload"></p><p>　　若想基于该写法实现真并发，可将p.join()改写为p.join(0.001)即可；代表着新建子进程后父进程的挂起时间仅为0.001秒，因此可以近似等价于同时执行；执行效果如下图所示：</p><p><img src="/images/placeholder.png" alt="join并行输出结果" data-src="./join并行输出结果.png" class="lazyload"></p><h1 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h1><p>　　Python-multiprocessing模块默认的子进程模式为非守护进程模式(即默认p.daemon=False)，意味着父进程完成后不影响子进程的执行，当子进程结束后父进程才会结束。若将p.daemon设置为True，则当父进程结束后，立马杀死子进程。</p><p>　　为什么当子进程运行周期大于父进程，且子进程不调用join时，没有僵尸进程进程？可能性猜测：</p><ul><li>可能性一：父进程结束后等待子进程结束；当子进程结束后，父进程退出的同时伴随着子进程做如下变化：子进程 =&gt; 僵尸进 =&gt; 孤儿进程 =&gt; 销毁</li><li>可能性二：父进程结束后等待子进程结束；当子进程结束后，父进程退出的同时会清除子进程</li></ul><p>　　此处就有一个疑问：<font color="red">当子进程为非守护进程时，父进程结束后为什么不结束，而是等待直到子进程结束后父进程才退出；父进程是如何感知到子进程的运行状态？</font></p><p>　　基于上述的理论推断第一种猜测的可能性比较合理，但是在实际监控(监控频率为0.001s)中并没有看到子进程状态的变化过程；相反实际的实验现象更像是第二种假设。但是因为没有调用join，所以父进程不会主动获取子进程的退出状态信息。</p><p>真正的原因还有待研究~~~</p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-Mysql依赖初探</title>
      <link href="/2018/06/01/Python-Mysql%E4%BE%9D%E8%B5%96%E5%88%9D%E6%8E%A2/"/>
      <content type="html"><![CDATA[<h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><blockquote><p>MySQL 5.7.17</p><p>Python 2.7</p><p>Mysql-python 1.2.5</p></blockquote><a id="more"></a><p>　　MySQLdb是基于MySQL C API(原生MySQL API)为核心的面向Python的接口，封装了许多MySQL C API的方法，简化Python操作MySQL的难度。在原生的MySQL API中，万物皆String。(当然，可以通过自定义conv来实现数据类型的转化)。官方解释如下图所示：</p><p><img src="./mysqldb_官方解释.png" alt="mysqldb_官方解释"></p><p>　　Eg：原始的数据源中，age列是int类型，基于原生API查询后，所有的结果均为String类型；执行效果如下图所示：</p><p><img src="./mysql原生写法.png" alt="mysql原生写法"></p><p>　　可以通过自定义转换dict来实现查询结果的类型转换；具体的实现也很简单，只需要在mysql初始化的时候，自定义conv参数即可(eg：将SQL中int转化为Long，将SQL中的float转化为Double)，样例代码如下图所示：</p><p><img src="./mysql原生写法_自定义conv参数.png" alt="mysql原生写法_自定义conv参数"></p><p>　　由于原始API并不是那么的拿来主义，直接基于此操作需要care的东西太多，所以才有了MySQLdb这样简单易上手的第三方依赖包。MySQLdb带来的便捷主要体现在一下两点：</p><ol><li>封装并提供很多API接口，降低使用门槛</li><li>自动适配原始SQL表的字段类型</li></ol><p>　　由于高级的API方法在实际工作中以用到很多，并且和其他语言的mysql驱动没太大差别，在这里不做讨论。重点分享一下第二点，在数据类型自定识别中，存在如下一种情况：<strong>基于MySQLdb查询int字段时，实际默认的返回类型是Long型，而非int</strong>。 Eg：</p><p><img src="./mysqldb写法.png" alt="mysqldb写法"></p><p>　　官方给出的解释是：<em>while MySQL’s INTEGER column translates perfectly into a Python integer, UNSIGNED INTEGER could overflow, so these values are converted to Python long integers instead</em>. 简单的说，就是<strong>MySQL的int类型转化为Python的int类型时，可能存在无符号整形精度丢失的情况</strong>。如何理解这句话：通过在程序中(Python)，不会刻意的定义一个无符号的整形变量，一般默认的int为有符号整形，eg：假如为int32，则对应的有符号整形的范围为：-2^(32-1) ~ 2^(32-1) - 1；相反无符号整数的范围为：0 ~ 2^32 - 1；所以当数据可中指定int为无符号整型时，程序中用有符号整形接受，就会存在因为数据范围不一致而导致的数据精度丢失情况。基于此原因，MySQLdb在设计时，为了规避该潜在问题，默认将int类型转化为long型。这就是为什么整形查询结果后面会带有L后缀的原因。</p><p>　　当然MySQLdb也可以支持类似原生API那种通过自定义conv参数的方式来实现数据类型的自定义(不过不建议用户这样操作)。Eg：将SQL中Long转化为int，将SQL中的double转化为flout，代码样例如下图所示：</p><p><img src="./mysqldb自定conv参数.png" alt="mysqldb自定conv参数"></p><p>　　因为MySQLdb对应所有的mysql数据类型都有一套自己默认的转化映射关系(详见源码：MySQLdb.converters)，对于原生API，可以指定自己想转化的特定数据列；但是该方法在MySQLdb中并不那么的适用；如果要自定义数据类型，就必须指定所涵盖的所有数据列，这样很有可能因为枚举不够全面而导致程序报错的情况；所以在实际工作时，不建议在这一步转化数据类型，如有需要，在将数据加载到内存后，再转化成所需要的类型。</p><p>参考链接：<a href="http://mysql-python.sourceforge.net/MySQLdb.html" target="_blank" rel="noopener">官方Doc</a> </p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MySQL </tag>
            
            <tag> MySQLdb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于pandas的数据分析之数据类型转化踩坑总结</title>
      <link href="/2018/06/01/%E5%9F%BA%E4%BA%8Epandas%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h3 id="从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题"><a href="#从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题" class="headerlink" title="从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题"></a>从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题</h3><ol><li>由于数据缺失导致DataFrame中int转float</li><li>由于数据类型字符串导致csv加载到DataFrame时String转numeric</li></ol><a id="more"></a><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><blockquote><p>MySQL 5.7.17</p><p>Python 2.7</p><p>MySQL-python 1.2.5</p><p>Pandas 0.18.1</p></blockquote><h1 id="一、由于数据缺失导致DataFrame中int转float"><a href="#一、由于数据缺失导致DataFrame中int转float" class="headerlink" title="一、由于数据缺失导致DataFrame中int转float"></a>一、由于数据缺失导致DataFrame中int转float</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>将MySQL的表结构转为Pandas的DataFrame时，会出现如下问题：</p><ul><li>age列原本为int类型，但是在DataFrame中转化为float类型</li><li>对于SQL中的None值，在DataFrame里有多种表示方式</li></ul><p>数据源信息如下所示：</p><p><img src="./表数据信息.png" alt="表数据信息"></p><p><img src="./表字段信息.png" alt="表字段信息"></p><p><img src="./表信息在DataFrame中的展示效果.png" alt="表信息在DataFrame中的展示效果"></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>　　通过查阅官方文档得知，pandas在处理缺失值上，拥有一套自己的转化逻辑；具体的转化规则如下图所示：</p><p><img src="./pandas缺失值处理规则.png" alt="pandas缺失值处理规则"></p><p>　　不难看出，当int型数据列包含空值时，会将该列转化为float类型；个人理解：在pandas中，对于数据类型的空值，是统一用Nan来表示的；Nan在pandas中是一float类型，代表一种特殊的值，而非其他语言中所定义的空对象；因此对于int类型的空值，因无法表示相应的空值，所以需要先做数据类型的转化，然后用Nan来表示其含义。</p><p><img src="./Python_nan值类型.png" alt="Python_nan值类型"></p><p>　　通过这个例子，希望在理解numeric类型转化原因的同时，能够提高对异常数据的警惕性和敏感度；理解业务，实现需求的同时，能有准确、有效的进行数据降噪，从而提升数据的真实性和可信度。</p><h1 id="由于数值类型字符串导致从csv加载到DataFrame时String转numeric"><a href="#由于数值类型字符串导致从csv加载到DataFrame时String转numeric" class="headerlink" title="由于数值类型字符串导致从csv加载到DataFrame时String转numeric"></a>由于数值类型字符串导致从csv加载到DataFrame时String转numeric</h1><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>缺失值分别在MySQL、Python和Pandas上的表现形式如下所示：</p><table><thead><tr><th>/</th><th>字符串空值</th><th>空字符串</th><th>数值类型空值</th></tr></thead><tbody><tr><td>MySQL</td><td>Null</td><td>‘’</td><td>Null</td></tr><tr><td>Python</td><td>None</td><td>‘’</td><td>None</td></tr><tr><td>Pandas</td><td>None</td><td>‘’</td><td>Nan</td></tr></tbody></table><p>　　<strong>由于字符串空值和空字符串这两种情况在写到csv的效果完全一致，从而导致在读取数据时无法做区分</strong>。如果后续业务明确要求区分处理这两种情况，则会因为一次文件的读写操作导致数据失真。基于此原因，建议在实际开发的过程中，在同一个team下规定一个唯一的字符串标识符来代表None值(参考数仓建设)，从而有效区分字符串空值和空字符串的区别。</p><h2 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h2><p>　　通过pd.read_csv方法加载csv文件时，如果某一列为数值字符串，则该列会别识别为numeric类型(eg：int, float)，而非原始的String类型。Eg：将前文中MySQL数据表中的sex列和passWord列的内容修改为纯数值，数据集及各列对应的数据类型分别如下所示：</p><p><img src="/images/placeholder.png" alt="数值型字符串数据集" data-src="./数值型字符串数据集.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="原始数据集数据类型" data-src="./原始数据集数据类型.png" class="lazyload"></p><p>　　并将该表中的数据先写到本地csv文件；然后通过pd.read_csv读取文件时发现sex列被识别为int类型，passWord列被识别为float类型。数据展示效果及各列对应的数据类型分别如下图所示：</p><p><img src="/images/placeholder.png" alt="经过一次读写操作后的数据集" data-src="./经过一次读写操作后的数据集.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="经过一次读写操作后的数据集数据类型" data-src="./经过一次读写操作后的数据集数据类型.png" class="lazyload"></p><p>　　所以在基于pandas操作csv文件时，需要特别注意这种情况。如果在后续的分析中，需要保留原始数据格式，则在读取csv文件时，需要通过dtype参数来显示的指定目标字段的数据类型，从而保证数据类型的前后统一。</p><p><img src="/images/placeholder.png" alt="读csv指定数据类型" data-src="./读csv指定数据类型.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="指定读取类型后的字段数据类型" data-src="./指定读取类型后的字段数据类型.png" class="lazyload"></p><p>　　通过上述案例分析，希望今后在操作csv文件时注意区分空字符串和字符串空值在不同应用场景下的实际意义，以免造成潜在的数据隐患。</p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于GitHub Pages + Hexo 多端搭建本地博客环境</title>
      <link href="/2018/05/28/%E5%9F%BA%E4%BA%8EGitHub-Pages-Hexo-%E5%A4%9A%E7%AB%AF%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读此文前，假定你已经了解如何基于GitHub Pages + Hexo来搭建个人博客。如果不了解的，可参考如下<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">教程</a>或<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">教程</a>(就不重复造轮子了)；为自己的博客添加主题，其实也很简单：只需要在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo</a>中挑选出自己心仪的风格，并将对应的源码从GitHub上clone到本地，并存放在你本地博客目录的themes路径下，并修改博客根目录的_config.yml文件，将theme: landscape中的landscape替换为你clone下来的文件夹名即可。具体操作参考<a href="http://www.cnblogs.com/fengxiongZz/p/7707568.html" target="_blank" rel="noopener">教程</a>。</p><a id="more"></a><p>接下来进入正题：搭建过个人博客的都清楚，Hexo是通过Node.js将本地的md文件(即就是你的博客源文件)基于指定的主题渲染成静态页面，在本地生成public文件夹，然后通过部署将public文件夹同步到GitHub上，这样你就可以通过username.github.io来访问。那么问题来了，当你如果换了台电脑或者想在其他机器上修改你的博客或者写一篇新博客，这就没招了。因为通过Hexo发布到GitHub上的是经过Node.js渲染过后的HTML文件，而非原始的md文件；所有你clone下GitHub上的源码也没什么用，除非你可以接受直接基于HTML写文档，那在这里我给你一个大写的服字。</p><h2 id="Hexo的安装过程"><a href="#Hexo的安装过程" class="headerlink" title="Hexo的安装过程"></a>Hexo的安装过程</h2><p>首先，通过<code>npm install hexo -g</code>在本地安装hexo(保证电脑上已经安装了git和node.js)</p><p>然后，在指定路径下执行<code>hexo init</code>命令来初始化hexo环境的相关文件，结果如下图所示：</p><p><img src="./hexo_init.png" alt="hexo初始化目录列表"></p><p>初始化出来的文件均为hexo环境配置</p><p>其次，通过<code>npm install</code>命令安装相关依赖，再通过<code>hexo g</code>来实现文档渲染，最后通过<code>hexo s</code>开始本地服务，如果报端口占用，可通过<code>hexo s -p 5000</code>重定向端口号，就可以通过localhost:5000来实现本地模式查看。当通过<code>hexo g</code>渲染文档后，会发现在博客根目录下新建了一个public目录，如下图所示：</p><p><img src="./hexo_g.png" alt="hexo渲染目录结构"></p><p>public目录就是最终发布到GitHub上的目录，node_module目录是执行完<code>npm install</code>后安装在本地的相关依赖，不用care它。</p><p>在理解了hexo的目录结构以后不难看出，其实博客网站只关注public目录；而hexo的环境信息(所使用的主题、所有博客的原md格式的文档、博客的配置信息)都是在scaffolds，source，themes和_config.yml中，所以只需要将这些文件维护到GitHub上，就可以随时随地在任何地方down下自己的环境文件，从而就可以开始你的创作了。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>在username.github.io仓库中新建一个hexo分支，用master分支来存放hexo发布的静态网页信息(即就是public目录下的内容)，用hexo分支来存放你的博客环境信息。其实当你执行完<code>hexo init</code>初始化命令后，你会发现hexo会默认帮你生成一个.gitignore文件，内容如下所示：</p><p><img src="./hexo_init_gitignore.png" alt="gitignore内容"></p><p>这里面已经自动帮你剔除了所有和hexo环境信息无关的目录了，所有你不做主动做任何过滤，直接在本地新建一个hexo分支，并将环境信息提交到GitHub对应的hexo分支即可。在博客根目录的_config.yml中指定deploy的branch为master分支即可。</p><h2 id="本地自测"><a href="#本地自测" class="headerlink" title="本地自测"></a>本地自测</h2><p>在本机新建一个文件夹，将username.github.io仓库的hexo分支clone到本地，然后执行<code>npm install</code>命令来安装所需要的相关相关依赖。<strong>切结不要执行<code>hexo init</code>命令</strong> ，因为该命令会初始化本地hexo环境，会用默认的hexo配置和主题来覆盖你自己的设置；因为我们hexo分支上的源码已经是自己当初所配置的环境，所以没必要初始化，只需要安装相关依赖，然后渲染自己的博客源文件<code>hexo g</code>,并在本地新开一个端口做测试<code>hexo s -p 5000</code>, 你会发现本地展示效果和通过username.github.io一致。至此已搞定全部问题。</p><p>需要注意的是，我这里是在本地做的测试。如果换台机器，保证已安装有git和node.js的前提下，按照上述再操作一遍即可。</p>]]></content>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
