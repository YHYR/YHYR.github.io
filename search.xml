<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>基于Python初探Linux下的僵尸进程和孤儿进程(二)</title>
      <link href="/2018/06/06/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%BA%8C/"/>
      <content type="html"><![CDATA[<p>了解Python-Process的join()方法的含义、以及在解决僵尸进程的原理和不足；同时结合实际应用场景提出有效可行的消除僵尸进程的方案。</p><a id="more"></a><h1 id="multiprocessing-Process的join-方法"><a href="#multiprocessing-Process的join-方法" class="headerlink" title="multiprocessing.Process的join()方法"></a>multiprocessing.Process的join()方法</h1><p>　　通过<a href="https://yhyr.github.io/2018/06/02/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">上篇博文</a>可以看出join()方法具有清除僵尸进程的作用，与此同时带来的负面作用就是子父进程的串行执行(此处假设我们的目标是保证子父进程的执行方式是非阻塞的；对于实际需求是需要父进程阻塞等待子进程结束后在执行的应用场景，可以忽略本篇博文)。接下来将从join的底层实现出发探究其能够清楚僵尸进程的原因和阻塞执行的方式；同时基于一个demo来给出实际工作中如何准确有效的避免和消除僵尸进程。</p><h2 id="join初探"><a href="#join初探" class="headerlink" title="join初探"></a>join初探</h2><p><img src="./join源码描述.png" alt="join源码描述"></p><p>　　基于PyCharm查看join的源码，如上图所示；官方描述该方法的功能是“等待，直到子进程结束”；从字面意思也不难看出，该方法是一个阻塞方法；需要注意的是这里<strong>等待的主语是主进程而非子进程</strong>。该方法主要做了两件事：</p><ol><li>(1) 通知父进程调用wait方法</li><li>(2) 将该子进程从父进程的子进程列表中移除</li></ol><p>　　第一件事调用wait方法背后的实际调用链是：process模块的join()  =&gt; forking模块的Popen.wait()，实则是调用了os.waitpd方法【注意这里的Popen根据操作系统的不同而不同，分为Union/Linux和Windows两种】；至于为什么要调用该方法可以看我<a href="https://yhyr.github.io/2018/06/02/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">上篇博文</a>中有关Linux进程基本概念模块的描述。</p><p><img src="./join底层调用.png" alt="join底层调用"></p><p>　　看到这，对于join()能消除僵尸进程的原因应该有了较为深刻的认识了；但是还存在一个问题：进程的串行执行问题还未解决。源码中join有一个timeout的参数，该参数的作用是设置一个该方法调用的等待时间，如果不设置，则等待子进程结束后在执行父进程；如果设置了，当子进程的运行周期大于你所设置的timeout时长时，表示过了timeout时长后(单位是秒)，开始唤醒父进程，此时子父进程开始同时执行；如果子进程的运行周期小与你所设置的timeout时长时，当你的子进程结束后会立即执行父进程，而不用等待你所设置的时长结束后才开始唤醒父进程。光说这些理论可能印象不会太深刻，接下来用几组例子来抛砖引玉，在加深对join理解的同时，介绍两种僵尸进程的有效清除办法。</p><p>样例代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, main_process_time, child_process_time)</span>:</span></span><br><span class="line">        self.main_process_time = main_process_time</span><br><span class="line">        self.child_process_time = child_process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excutor</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'main process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        p = ChildProcess(self.child_process_time)</span><br><span class="line">        p.start()</span><br><span class="line">        p.join(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.main_process_time):</span><br><span class="line">            print(<span class="string">'main process, pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_time)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.process_time = process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'child process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.process_time):</span><br><span class="line">            print(<span class="string">'child process pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'child process end, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_process_time = <span class="number">15</span></span><br><span class="line">    child_process_time = <span class="number">10</span></span><br><span class="line">    action = MainProcess(main_process_time, child_process_time)</span><br><span class="line">    action.excutor()</span><br></pre></td></tr></table></figure><h2 id="场景一：子进程的运行周期大于父进程"><a href="#场景一：子进程的运行周期大于父进程" class="headerlink" title="场景一：子进程的运行周期大于父进程"></a>场景一：子进程的运行周期大于父进程</h2><p>　　在该应用场景下，无论是否调用join方法都不会有僵尸进程存在；如果调用join，则父进程会被挂起，子父进程串行执行；如果不调用join，子父进程并行执行；现在分析一下调用带参数的join方法(eg：p.join(3))，当父进程启动，子进程执行时间小于三秒时，执行效果如下图所示：</p><p><img src="./子进程周期大于父进程,join带参数且子进程运行时间小于三秒.png" alt="子进程周期大于父进程,join带参数且子进程运行时间小于三秒"></p><p>当子进程执行时间大于三秒且小于父进程的执行周期时，执行效果如下图所示：</p><p><img src="./子进程周期大于父进程,join带参数且子进程运行时间大于三秒小于父进程周期.png" alt="子进程周期大于父进程,join带参数且子进程运行时间大于三秒小于父进程周期"></p><p>当父进程结束，而子进程继续执行，程序输出结果如下图所示：</p><p><img src="./子进程周期大于父进程,join带参数且父进程结束.png" alt="子进程周期大于父进程,join带参数且父进程结束"></p><h2 id="场景二：子进程的运行周期小与父进程"><a href="#场景二：子进程的运行周期小与父进程" class="headerlink" title="场景二：子进程的运行周期小与父进程"></a>场景二：子进程的运行周期小与父进程</h2><p>　　在该应用场景下，如果不调用join，则会有僵尸进程产生；如果调用join，则可以消除僵尸进程，但是子父进程串行执行；这种结果也并非我们所需要的。接下来尝试一下调用带参数的join方法(eg：p.join(3))，修改上述样例代码将main_process_time设置为15，child_process_time设置为10：</p><p>当父进程启动，子进程执行时间小于三秒时，执行效果如下图所示：</p><p><img src="/images/placeholder.png" alt="子进程周期小与父进程，join带参数且子进程执行时间小于三秒" data-src="./子进程周期小与父进程，join带参数且子进程执行时间小于三秒.png" class="lazyload"></p><p>当子进程执行时间大于三秒且小于子进程的执行周期时，执行效果如下图所示：</p><p><img src="/images/placeholder.png" alt="子进程周期小与父进程，join带参数且子进程执行时间大于三秒且小于子进程周期" data-src="./子进程周期小与父进程，join带参数且子进程执行时间大于三秒且小于子进程周期.png" class="lazyload"></p><p>当子进程结束，父进程继续执行时，程序输出结果如下图所示：</p><p><img src="/images/placeholder.png" alt="子进程周期小与父进程，join带参数且子进程结束" data-src="./子进程周期小与父进程，join带参数且子进程结束.png" class="lazyload"></p><p>　　通过这个例子可以看出，在该应用场景下，<font color="red">不论是加了带参数的join还是不加join，都会有僵尸进程产生</font>；相反加了不带参数的join虽可以避免僵尸进程，但是还是不满足我们的需求(子父进程的并行执行)；为什么带参数和不带参数的join执行效果会如此大相径庭呢？其实通过上述源码是可以看出，<strong>join方法确实是会调用系统的os.waitpid()方法来获取子进程的退出信息，从而达到消除子进程的目的；但是这个过程是一次性的</strong>。什么意思呢？就是如果不带参数，则会一直挂起父进程，知道子进程结束后再执行p.join()方法，从而清除子进程；相反如果带参数，则会挂起父进程timeout时长后，唤醒父进程，此时父进程会调用p.join(3)，如果此时子进程还未结束，则p.join(3)获取子进程的退出状态信息为空，则不会清除子进程，然后回继续执行父进程的后续逻辑；此时子父进程就开始并行执行；如果子进程在次之后结束的同时父进程还未结束，则父进程会因为无法获取到子进程的退出信息而导致子进程沦为僵尸进程。(开始自己以为join(3)意味着父进程会在三秒后唤醒的同时，父进程会轮询监控子进程的退出信息，从而达到消除僵尸进程的作用，^v^ 还是太年轻~想当然了~哈哈！！！)。</p><h1 id="消除僵尸进程"><a href="#消除僵尸进程" class="headerlink" title="消除僵尸进程"></a>消除僵尸进程</h1><p>　　随着对Process的join()方法的深入理解，越发觉得离我们的目标渐行渐远。要不就会产生僵尸进程，要不就会挂起父进程，从而无法实现并行效果。那么问题来了，到底该如何有效的消除僵尸进程呢？</p><p>　　网上有些帖子和博客说可以通过os._exti(0)或者sys.exit(0)可以有效的退出子进程，这一点毋庸置疑；但是需要注意的是这种退出并没有什么太大的作用，因为主动退出子进程并不会通知父进程去获取子进程得退出状态信息，从而导致子进程还是会变成僵尸进程。在这里我将介绍两种行之有效的方法来实现彻底消除僵尸进程的同时，实现子父进程的并发。</p><h2 id="方法一：创建两次子进程-fork两次"><a href="#方法一：创建两次子进程-fork两次" class="headerlink" title="方法一：创建两次子进程(fork两次)"></a>方法一：创建两次子进程(fork两次)</h2><p>　　如果百度过此类问题的不难发现，网上有很多说可以通过fork两次来清除僵尸进程。其实这是一个很不错的方法，也是一个比较容易理解的。只是关于该方法的解释不是很多(可能因为笔者太low，对于很多人来说都是一看就懂的^v^)，在这里我将就该方法做以详细的解释和说明，希望对刚接触此类问题的小伙伴们有所帮助。</p><p>　　首先需要注意的是fork函数是union/linux系统上特有的，在Windows上运行该函数会直接报错，而恰巧笔者是没屌丝，用Windows机器做开发，在Linux上跑代码的这种，直接在Linux上写代码又是比较麻烦的(如果愿意可以基于VM搭建一个桌面版的CentOS，然后装个编译器来开发)，所以这里笔者从一开始就选择Python提供的一种跨平台的多进程模块 – multiprocessing来实现多进程(其实multiprocessing中基于Linux的代码实现逻辑就是fork，对于该模块源码初探可详见<a href="https://yhyr.github.io/" target="_blank" rel="noopener">传送门</a>)。</p><p>　　如何理解fork两次即可达到我们想要的想过呢？此处假设我们的业务场景是父进程一直存在，而子进程的执行周期短，且执行完后就退出。我们知道，当主进程创建一个子进程时，此时子进程的ppid即就是父进程的pid；而子进程结束后如果父进程没有获取子进程的退出状态信息，则子进程会变成僵尸进程；我们又知道，如果一个子进程是孤儿进程的话，那么它就是安全可靠的(不会产生僵尸进程)；所以基于这种原因，可以进行如下设计：主进程的业务逻辑保持不变，只是在主进程创建子进程的时候，不直接创建子进程去执行相应的业务逻辑；而是创建一个单独进程(此处理解为爸爸进程)，该进程只干一件事，就是创建原本应该有父进程创建的子进程。即就是<font color="red">将原本的“主进程 =&gt; 儿子进程”修改为“主进程 =&gt; 爸爸进程 =&gt; 儿子进程”</font>，这种设计里只有主进程和儿子进程是需要关注的，而爸爸进程逻辑很简单，就是初始化儿子进程；所以当爸爸进程结束后儿子进程就沦为孤儿进程了，这样无论儿子进程执行多久，都不会产生僵尸进程。</p><p>　　有人就会想，爸爸进程退出不也会产生僵尸进程吗？其实这个问题很好解决，利用上述中的不带参数的join()方法即可解决。可以在主进程中创建父进程的同时，添加p.join()方法，因为爸爸进程创建儿子进程的耗时很短，所以可以在主进程创建爸爸进程的时候使用p.join()挂起，这个时间差是可以忽略和接受的，这样当父进程创建完儿子进程后父进程就会立马结束，此时主进程就会执行p.join()方法获取到爸爸进程的退出信息，从而彻底消除爸爸进程；这样进程列表里就只剩下一个主进程和一个而孤儿进程(原本的儿子进程转化而来)；这样就实现了真正意义上的并发。为了测试时效果看的明显，在源码中添加了sleep()，如果在实际的业务开发中，可以注掉源码中的相关sleep()代码，具体源码如下所示(该写法可兼容Windows和Linux)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, main_process_time, child_process_time)</span>:</span></span><br><span class="line">        self.main_process_time = main_process_time</span><br><span class="line">        self.child_process_time = child_process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excutor</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'main process begin, pid=&#123;0&#125;'</span>.format(os.getpid()))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        p = FatherProcess(self.child_process_time)</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.main_process_time):</span><br><span class="line">            print(<span class="string">'main process, pid=&#123;0&#125;, times=&#123;1&#125;'</span>.format(os.getpid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'main process end, pid=&#123;0&#125;'</span>.format(os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_time)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.process_time = process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'father process begin, pid=&#123;&#125; =&gt; create childPorcess'</span>.format(os.getpid()))</span><br><span class="line">        p = ChildProcess(self.process_time)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        p.start()</span><br><span class="line">        print(<span class="string">'father process end, pid=&#123;&#125;'</span>.format(os.getpid()))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_time)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.process_time = process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'child process begin, pid=&#123;0&#125;'</span>.format(os.getpid()))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.process_time):</span><br><span class="line">            print(<span class="string">'child process pid=&#123;0&#125;, times=&#123;1&#125;'</span>.format(os.getpid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'child process end, pid=&#123;0&#125;'</span>.format(os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_process_time = <span class="number">10</span></span><br><span class="line">    child_process_time = <span class="number">5</span></span><br><span class="line">    action = MainProcess(main_process_time, child_process_time)</span><br><span class="line">    action.excutor()</span><br></pre></td></tr></table></figure><h2 id="方法二：基于Linux信号清除僵尸进程"><a href="#方法二：基于Linux信号清除僵尸进程" class="headerlink" title="方法二：基于Linux信号清除僵尸进程"></a>方法二：基于Linux信号清除僵尸进程</h2><p>　　创建两次子进程的方法是比较好理解的，但是代码的入侵还是比较大的，基于Linux信号的方式可以只需要添加一行代码就实现所需要的逻辑；不过该解决方案只适用于Linux/Union系统；在Windows下执行是会报错。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, main_process_time, child_process_time)</span>:</span></span><br><span class="line">        self.main_process_time = main_process_time</span><br><span class="line">        self.child_process_time = child_process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excutor</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'main process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        添加信号</span></span><br><span class="line"><span class="string">            signal.SIGCHLD的语义为：子进程状态改变后产生此信号</span></span><br><span class="line"><span class="string">            signal.SIG_IGN的语义为：信号的处理方式为忽略模式</span></span><br><span class="line"><span class="string">            默认采用SIG_DFL, 代表默认的处理方式为不会理会这个信号，但是也不会丢弃该信号量，</span></span><br><span class="line"><span class="string">            如果系统不调用wait/waitpid，则会变成僵尸进程</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            第二个参数也可以自定义处理逻辑，eg：将signal.SIG_IGN修改为自定义sigchld_handler方法，</span></span><br><span class="line"><span class="string">            专门用来处理对应的信号</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        signal.signal(signal.SIGCHLD, signal.SIG_IGN)</span><br><span class="line"></span><br><span class="line">        p = ChildProcess(self.child_process_time)</span><br><span class="line">        p.start()</span><br><span class="line">        p.join(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.main_process_time):</span><br><span class="line">            print(<span class="string">'main process, pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_time)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.process_time = process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'child process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.process_time):</span><br><span class="line">            print(<span class="string">'child process pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'child process end, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_process_time = <span class="number">30</span></span><br><span class="line">    child_process_time = <span class="number">15</span></span><br><span class="line">    action = MainProcess(main_process_time, child_process_time)</span><br><span class="line">    action.excutor()</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Python初探Linux下的僵尸进程和孤儿进程(一)</title>
      <link href="/2018/06/02/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<p><em>通过对比子父进程的执行周期来详细讨论僵尸进程产生的原因和规避方法</em></p><a id="more"></a><p>样例代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, main_process_time, child_process_time)</span>:</span></span><br><span class="line">        self.main_process_time = main_process_time</span><br><span class="line">        self.child_process_time = child_process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excutor</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'main process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        p = ChildProcess(self.child_process_time)</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.main_process_time):</span><br><span class="line">            print(<span class="string">'main process, pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'main process end, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, process_time)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.process_time = process_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'child process begin, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.process_time):</span><br><span class="line">            print(<span class="string">'child process pid=&#123;0&#125;, ppid=&#123;1&#125;, times=&#123;2&#125;'</span>.format(os.getpid(), os.getppid(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'child process end, pid=&#123;0&#125;, ppid=&#123;1&#125;'</span>.format(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main_process_time = <span class="number">5</span></span><br><span class="line">    child_process_time = <span class="number">10</span></span><br><span class="line">    action = MainProcess(main_process_time, child_process_time)</span><br><span class="line">    action.excutor()</span><br></pre></td></tr></table></figure><h1 id="业务场景及现象描述"><a href="#业务场景及现象描述" class="headerlink" title="业务场景及现象描述"></a>业务场景及现象描述</h1><h2 id="场景一：子进程的运行周期大于父进程"><a href="#场景一：子进程的运行周期大于父进程" class="headerlink" title="场景一：子进程的运行周期大于父进程"></a>场景一：子进程的运行周期大于父进程</h2><h3 id="子进程不调用join-方法：无僵尸进程存在"><a href="#子进程不调用join-方法：无僵尸进程存在" class="headerlink" title="子进程不调用join()方法：无僵尸进程存在"></a>子进程不调用join()方法：无僵尸进程存在</h3><p>样例代码中main_process_time代表主进程运行时长，child_process_time代表子进程运行时长；并注释掉p.join()，代码执行逻辑如下所述：</p><p>　　父进程执行到p.start()后，子父进程开始同时执行；当父进程结束后，子进程继续执行；此时父进程并不退出依然存在，且进程状态依然为休眠状态(S+)；当子进程结束后，子父进程同时销毁。打印结果如下图所示：</p><p><img src="./子进程运行周期长，且不调用join.png" alt="子进程运行周期长，且不调用join"></p><h3 id="子进程调用join-方法：无僵尸进程存在"><a href="#子进程调用join-方法：无僵尸进程存在" class="headerlink" title="子进程调用join()方法：无僵尸进程存在"></a>子进程调用join()方法：无僵尸进程存在</h3><p>取消p.join()的注释，代码执行逻辑如下所述：</p><p>　　首先启动父进程，当执行到p.start()后，子进程开始执行，此时父进程处于挂起状态；当子进程结束后，父进程开始继续执行后续代码。打印结果如下图所示：</p><p><img src="./子进程运行周期长，调用无参join.png" alt="子进程运行周期长，调用无参join"></p><h2 id="场景二：子进程运行周期小与父进程"><a href="#场景二：子进程运行周期小与父进程" class="headerlink" title="场景二：子进程运行周期小与父进程"></a>场景二：子进程运行周期小与父进程</h2><h3 id="子进程不调用join-方法：有僵尸进程存在"><a href="#子进程不调用join-方法：有僵尸进程存在" class="headerlink" title="子进程不调用join()方法：有僵尸进程存在"></a>子进程不调用join()方法：<font color="red">有僵尸进程存在</font></h3><p>修改main_process_time为30，child_process_time为10；并注释掉p.join()，代码执行逻辑如下所述：</p><p>　　首先启动父进程，当执行到p.start()后，子父进程开始同时执行；<font color="red">当子进程尚未结束时</font>，子父进程的打印结果及其进程状态如下图所示：</p><p><img src="./父进程运行周期长，不调用join，且子进程尚未结束.png" alt="父进程运行周期长，不调用join，且子进程尚未结束"></p><p><font color="red">当子进程结束，但父进程尚未结束时，子进程变为僵尸进程</font>，进程的打印结果和进程状态如下图所示：</p><p><img src="./父进程运行周期长，不调用join，且子进程已经结束.png" alt="父进程运行周期长，不调用join，且子进程已经结束"></p><h3 id="子进程调用join-方法：无僵尸进程存在-1"><a href="#子进程调用join-方法：无僵尸进程存在-1" class="headerlink" title="子进程调用join()方法：无僵尸进程存在"></a>子进程调用join()方法：无僵尸进程存在</h3><p>修改main_process_time为30，child_process_time为10；并取消p.join()的注释，代码执行逻辑如下所述：</p><p>　　当父进程执行到p.start()后，子进程开始执行，且父进程挂起；当子进程尚未结束时，程序打印结果以及系统中进程状态如下图所示：</p><p><img src="./父进程运行周期长，调用无参join，且子进程尚未结束.png" alt="父进程运行周期长，调用无参join，且子进程尚未结束"></p><p><font color="red">当子进程结束而父进程尚未结束时，子进程正常销毁</font>，此时只有父进程在继续运行;程序打印结果以及系统中进程状态如下图所示：</p><p><img src="/images/placeholder.png" alt="父进程运行周期长，调用无参join，且子进程已经结束" data-src="./父进程运行周期长，调用无参join，且子进程已经结束.png" class="lazyload"></p><h2 id="子父进程伪并发"><a href="#子父进程伪并发" class="headerlink" title="子父进程伪并发"></a>子父进程伪并发</h2><p>　　在写代码的时候，需要注意join()方法位置；否则有可能会导致看似的多进程并发代码，实则的多进程的串行执行。Eg：将样例代码中的MainProcess类的excutor方法改写成如下形式：</p><p><img src="/images/placeholder.png" alt="join串行代码写法" data-src="./join串行代码写法.png" class="lazyload"></p><p>　　当基于for循环创建子进程时，若将p.join()卸载循环体内，则实际的执行逻辑为：主线程 =&gt; 子线程1 =&gt; 子线程2 =&gt; 子线程3 =&gt; 主线程；代码打印结果如下图所示：</p><p><img src="/images/placeholder.png" alt="join串行代码输出结果" data-src="./join串行代码输出结果.png" class="lazyload"></p><p>　　若想基于该写法实现真并发，可将p.join()改写为p.join(0.001)即可；代表着新建子进程后父进程的挂起时间仅为0.001秒，因此可以近似等价于同时执行；执行效果如下图所示：</p><p><img src="/images/placeholder.png" alt="join并行输出结果" data-src="./join并行输出结果.png" class="lazyload"></p><p>不过不建议采用这样的写法，因为这样会产生僵尸进程(详见<a href="https://yhyr.github.io" target="_blank" rel="noopener">join详解</a>)。</p><h1 id="Linux进程基本概念"><a href="#Linux进程基本概念" class="headerlink" title="Linux进程基本概念"></a>Linux进程基本概念</h1><p>　　在Linux中，默认情况下当父进程创建完子进程后，子父进程的运行时相互独立的、异步的；即父进程无法感知到子进程何时结束。为了让父进程可以在任意时刻都能获取到子进程结束时的状态信息，提供了如下机制：</p><ul><li>1) 当子进程结束后，系统在释放该子进程的所有资源(eg：占用的内存、打开的文件等)，仍会保留一定的信息，包括进程号(process id)，进程的退出状态(the termination status of the process)，运行时间(the amount of CPU time taken by the process)等。</li><li>2) 当父进程调用wait/waitpid方法获取子进程的退出状态信息后，系统会彻底释放掉对应子进程的所有信息。如果父进程没有调用wait/waitpid方法，且父进程一直存活，则该子进程所有用的端口号信息一直保存，从而该子进程变为僵尸进程(对系统有害)；若父进程没有调用wait/waitpid方法，且父进程已经结束，则子进程会从僵尸进程转变为孤儿进程(对系统无害)。</li></ul><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>　　一个进程创建了一个子进程，且当该子进程结束后，父进程没有调用wait/waitpid方法来获取子进程的退出状态信息，那么该子进程将会一直保留在系统中，并持续占有该进程的端口号等信息；进程标识符为<code>&lt;defunct&gt;</code>，进程状态位为Z，这种进程称之为僵尸进程。如下图所示：</p><p><img src="/images/placeholder.png" alt="僵尸进程" data-src="./僵尸进程.png" class="lazyload"></p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>　　当父进程退出而子进程还在运行时，这些子进程将会变成孤儿进程。孤儿进程将会init进程统一管理。因为init进程的进程号为1，所以所有的孤儿进程的父进程号均为1；此外，因为init进程会主动收集所有子进程的退出状态信息，所有由init进程管理的子进程是不会变成僵尸进程。因此，孤儿进程是对系统无害的。</p><p>　　例如：在上述样例代码的基础上，将子父进程的运行周期均扩大为60(保证有足够的时间去手动kill掉父进程，方便举例验证)，当子父进程运行的同时，手动kill掉父进程，子进程的进程号变化如下图所示</p><p>kill前：</p><p><img src="/images/placeholder.png" alt="孤儿进程手动kill前" data-src="./孤儿进程手动kill前.png" class="lazyload"></p><p>kill后：</p><p><img src="/images/placeholder.png" alt="孤儿进程手动kill后" data-src="./孤儿进程手动kill后.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　Linux中，如果父进程正常结束的同时，子进程还未结束，此时父进程并不会退出让子进程变成孤儿进程，而是会有一个等待的操作；以阻塞或者轮询的方式等待所有子进程的结束而结束，毕竟“爸爸管儿子是天经地义的事”；正因为如此，在该应用场景一下(子进程的运行周期大于父进程)，即使不调用join()方法，也不会存在僵尸进程。如果在父进程在执行过程中因为调用os.exit()或者外部直接kill掉，此处父进程就不会在管理自己所产生的子进程，从而会导致子进程变成孤儿进程。相反如果子进程结束时父进程还未结束，此时如果未调用join()方法，则会因为父进程没有获取并处理子进程的退出信息而导致子进程变成僵尸进程；如果父进程一直存在，则该僵尸进程也会一直存在，相反如果父进程结束，则父进程在结束的前会等待并清除自己所产生的所有子进程的退出信息，从而消除僵尸进程。</p><p>　　通过上述demo，可以看出在不加join的时候，子父进程的运行方式是一种真正意义上的并行，但是由于特定的场景会导致出现僵尸进程；而加了join后，可以有效的消除僵尸进程，但是所写的多进程代码实则是一种多进程的串行执行模式(即：父进程会等待子进程结束后在执行)，其实是因为join()方法本身就是一种以阻塞主进程来等待子进程的方法。关于join()的解释和切实有效的消除僵尸进程可详见<a href="https://yhyr.github.io/" target="_blank" rel="noopener">传送门</a></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-Mysql依赖初探</title>
      <link href="/2018/06/01/Python-Mysql%E4%BE%9D%E8%B5%96%E5%88%9D%E6%8E%A2/"/>
      <content type="html"><![CDATA[<h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><blockquote><p>MySQL 5.7.17</p><p>Python 2.7</p><p>Mysql-python 1.2.5</p></blockquote><a id="more"></a><p>　　MySQLdb是基于MySQL C API(原生MySQL API)为核心的面向Python的接口，封装了许多MySQL C API的方法，简化Python操作MySQL的难度。在原生的MySQL API中，万物皆String。(当然，可以通过自定义conv来实现数据类型的转化)。官方解释如下图所示：</p><p><img src="./mysqldb_官方解释.png" alt="mysqldb_官方解释"></p><p>　　Eg：原始的数据源中，age列是int类型，基于原生API查询后，所有的结果均为String类型；执行效果如下图所示：</p><p><img src="./mysql原生写法.png" alt="mysql原生写法"></p><p>　　可以通过自定义转换dict来实现查询结果的类型转换；具体的实现也很简单，只需要在mysql初始化的时候，自定义conv参数即可(eg：将SQL中int转化为Long，将SQL中的float转化为Double)，样例代码如下图所示：</p><p><img src="./mysql原生写法_自定义conv参数.png" alt="mysql原生写法_自定义conv参数"></p><p>　　由于原始API并不是那么的拿来主义，直接基于此操作需要care的东西太多，所以才有了MySQLdb这样简单易上手的第三方依赖包。MySQLdb带来的便捷主要体现在一下两点：</p><ol><li>封装并提供很多API接口，降低使用门槛</li><li>自动适配原始SQL表的字段类型</li></ol><p>　　由于高级的API方法在实际工作中以用到很多，并且和其他语言的mysql驱动没太大差别，在这里不做讨论。重点分享一下第二点，在数据类型自定识别中，存在如下一种情况：<strong>基于MySQLdb查询int字段时，实际默认的返回类型是Long型，而非int</strong>。 Eg：</p><p><img src="./mysqldb写法.png" alt="mysqldb写法"></p><p>　　官方给出的解释是：<em>while MySQL’s INTEGER column translates perfectly into a Python integer, UNSIGNED INTEGER could overflow, so these values are converted to Python long integers instead</em>. 简单的说，就是<strong>MySQL的int类型转化为Python的int类型时，可能存在无符号整形精度丢失的情况</strong>。如何理解这句话：通过在程序中(Python)，不会刻意的定义一个无符号的整形变量，一般默认的int为有符号整形，eg：假如为int32，则对应的有符号整形的范围为：-2^(32-1) ~ 2^(32-1) - 1；相反无符号整数的范围为：0 ~ 2^32 - 1；所以当数据可中指定int为无符号整型时，程序中用有符号整形接受，就会存在因为数据范围不一致而导致的数据精度丢失情况。基于此原因，MySQLdb在设计时，为了规避该潜在问题，默认将int类型转化为long型。这就是为什么整形查询结果后面会带有L后缀的原因。</p><p>　　当然MySQLdb也可以支持类似原生API那种通过自定义conv参数的方式来实现数据类型的自定义(不过不建议用户这样操作)。Eg：将SQL中Long转化为int，将SQL中的double转化为flout，代码样例如下图所示：</p><p><img src="./mysqldb自定conv参数.png" alt="mysqldb自定conv参数"></p><p>　　因为MySQLdb对应所有的mysql数据类型都有一套自己默认的转化映射关系(详见源码：MySQLdb.converters)，对于原生API，可以指定自己想转化的特定数据列；但是该方法在MySQLdb中并不那么的适用；如果要自定义数据类型，就必须指定所涵盖的所有数据列，这样很有可能因为枚举不够全面而导致程序报错的情况；所以在实际工作时，不建议在这一步转化数据类型，如有需要，在将数据加载到内存后，再转化成所需要的类型。</p><p>参考链接：<a href="http://mysql-python.sourceforge.net/MySQLdb.html" target="_blank" rel="noopener">官方Doc</a> </p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MySQL </tag>
            
            <tag> MySQLdb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于pandas的数据分析之数据类型转化踩坑总结</title>
      <link href="/2018/06/01/%E5%9F%BA%E4%BA%8Epandas%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h3 id="从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题"><a href="#从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题" class="headerlink" title="从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题"></a>从以下两个方面来讨论在实际工作中所遇到的数据类型转化问题</h3><ol><li>由于数据缺失导致DataFrame中int转float</li><li>由于数据类型字符串导致csv加载到DataFrame时String转numeric</li></ol><a id="more"></a><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><blockquote><p>MySQL 5.7.17</p><p>Python 2.7</p><p>MySQL-python 1.2.5</p><p>Pandas 0.18.1</p></blockquote><h1 id="一、由于数据缺失导致DataFrame中int转float"><a href="#一、由于数据缺失导致DataFrame中int转float" class="headerlink" title="一、由于数据缺失导致DataFrame中int转float"></a>一、由于数据缺失导致DataFrame中int转float</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>将MySQL的表结构转为Pandas的DataFrame时，会出现如下问题：</p><ul><li>age列原本为int类型，但是在DataFrame中转化为float类型</li><li>对于SQL中的None值，在DataFrame里有多种表示方式</li></ul><p>数据源信息如下所示：</p><p><img src="./表数据信息.png" alt="表数据信息"></p><p><img src="./表字段信息.png" alt="表字段信息"></p><p><img src="./表信息在DataFrame中的展示效果.png" alt="表信息在DataFrame中的展示效果"></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>　　通过查阅官方文档得知，pandas在处理缺失值上，拥有一套自己的转化逻辑；具体的转化规则如下图所示：</p><p><img src="./pandas缺失值处理规则.png" alt="pandas缺失值处理规则"></p><p>　　不难看出，当int型数据列包含空值时，会将该列转化为float类型；个人理解：在pandas中，对于数据类型的空值，是统一用Nan来表示的；Nan在pandas中是一float类型，代表一种特殊的值，而非其他语言中所定义的空对象；因此对于int类型的空值，因无法表示相应的空值，所以需要先做数据类型的转化，然后用Nan来表示其含义。</p><p><img src="./Python_nan值类型.png" alt="Python_nan值类型"></p><p>　　通过这个例子，希望在理解numeric类型转化原因的同时，能够提高对异常数据的警惕性和敏感度；理解业务，实现需求的同时，能有准确、有效的进行数据降噪，从而提升数据的真实性和可信度。</p><h1 id="由于数值类型字符串导致从csv加载到DataFrame时String转numeric"><a href="#由于数值类型字符串导致从csv加载到DataFrame时String转numeric" class="headerlink" title="由于数值类型字符串导致从csv加载到DataFrame时String转numeric"></a>由于数值类型字符串导致从csv加载到DataFrame时String转numeric</h1><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>缺失值分别在MySQL、Python和Pandas上的表现形式如下所示：</p><table><thead><tr><th>/</th><th>字符串空值</th><th>空字符串</th><th>数值类型空值</th></tr></thead><tbody><tr><td>MySQL</td><td>Null</td><td>‘’</td><td>Null</td></tr><tr><td>Python</td><td>None</td><td>‘’</td><td>None</td></tr><tr><td>Pandas</td><td>None</td><td>‘’</td><td>Nan</td></tr></tbody></table><p>　　<strong>由于字符串空值和空字符串这两种情况在写到csv的效果完全一致，从而导致在读取数据时无法做区分</strong>。如果后续业务明确要求区分处理这两种情况，则会因为一次文件的读写操作导致数据失真。基于此原因，建议在实际开发的过程中，在同一个team下规定一个唯一的字符串标识符来代表None值(参考数仓建设)，从而有效区分字符串空值和空字符串的区别。</p><h2 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h2><p>　　通过pd.read_csv方法加载csv文件时，如果某一列为数值字符串，则该列会别识别为numeric类型(eg：int, float)，而非原始的String类型。Eg：将前文中MySQL数据表中的sex列和passWord列的内容修改为纯数值，数据集及各列对应的数据类型分别如下所示：</p><p><img src="/images/placeholder.png" alt="数值型字符串数据集" data-src="./数值型字符串数据集.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="原始数据集数据类型" data-src="./原始数据集数据类型.png" class="lazyload"></p><p>　　并将该表中的数据先写到本地csv文件；然后通过pd.read_csv读取文件时发现sex列被识别为int类型，passWord列被识别为float类型。数据展示效果及各列对应的数据类型分别如下图所示：</p><p><img src="/images/placeholder.png" alt="经过一次读写操作后的数据集" data-src="./经过一次读写操作后的数据集.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="经过一次读写操作后的数据集数据类型" data-src="./经过一次读写操作后的数据集数据类型.png" class="lazyload"></p><p>　　所以在基于pandas操作csv文件时，需要特别注意这种情况。如果在后续的分析中，需要保留原始数据格式，则在读取csv文件时，需要通过dtype参数来显示的指定目标字段的数据类型，从而保证数据类型的前后统一。</p><p><img src="/images/placeholder.png" alt="读csv指定数据类型" data-src="./读csv指定数据类型.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="指定读取类型后的字段数据类型" data-src="./指定读取类型后的字段数据类型.png" class="lazyload"></p><p>　　通过上述案例分析，希望今后在操作csv文件时注意区分空字符串和字符串空值在不同应用场景下的实际意义，以免造成潜在的数据隐患。</p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于GitHub Pages + Hexo 多端搭建本地博客环境</title>
      <link href="/2018/05/28/%E5%9F%BA%E4%BA%8EGitHub-Pages-Hexo-%E5%A4%9A%E7%AB%AF%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读此文前，假定你已经了解如何基于GitHub Pages + Hexo来搭建个人博客。如果不了解的，可参考如下<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">教程</a>或<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">教程</a>(就不重复造轮子了)；为自己的博客添加主题，其实也很简单：只需要在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo</a>中挑选出自己心仪的风格，并将对应的源码从GitHub上clone到本地，并存放在你本地博客目录的themes路径下，并修改博客根目录的_config.yml文件，将theme: landscape中的landscape替换为你clone下来的文件夹名即可。具体操作参考<a href="http://www.cnblogs.com/fengxiongZz/p/7707568.html" target="_blank" rel="noopener">教程</a>。</p><a id="more"></a><p>接下来进入正题：搭建过个人博客的都清楚，Hexo是通过Node.js将本地的md文件(即就是你的博客源文件)基于指定的主题渲染成静态页面，在本地生成public文件夹，然后通过部署将public文件夹同步到GitHub上，这样你就可以通过username.github.io来访问。那么问题来了，当你如果换了台电脑或者想在其他机器上修改你的博客或者写一篇新博客，这就没招了。因为通过Hexo发布到GitHub上的是经过Node.js渲染过后的HTML文件，而非原始的md文件；所有你clone下GitHub上的源码也没什么用，除非你可以接受直接基于HTML写文档，那在这里我给你一个大写的服字。</p><h2 id="Hexo的安装过程"><a href="#Hexo的安装过程" class="headerlink" title="Hexo的安装过程"></a>Hexo的安装过程</h2><p>首先，通过<code>npm install hexo -g</code>在本地安装hexo(保证电脑上已经安装了git和node.js)</p><p>然后，在指定路径下执行<code>hexo init</code>命令来初始化hexo环境的相关文件，结果如下图所示：</p><p><img src="./hexo_init.png" alt="hexo初始化目录列表"></p><p>初始化出来的文件均为hexo环境配置</p><p>其次，通过<code>npm install</code>命令安装相关依赖，再通过<code>hexo g</code>来实现文档渲染，最后通过<code>hexo s</code>开始本地服务，如果报端口占用，可通过<code>hexo s -p 5000</code>重定向端口号，就可以通过localhost:5000来实现本地模式查看。当通过<code>hexo g</code>渲染文档后，会发现在博客根目录下新建了一个public目录，如下图所示：</p><p><img src="./hexo_g.png" alt="hexo渲染目录结构"></p><p>public目录就是最终发布到GitHub上的目录，node_module目录是执行完<code>npm install</code>后安装在本地的相关依赖，不用care它。</p><p>在理解了hexo的目录结构以后不难看出，其实博客网站只关注public目录；而hexo的环境信息(所使用的主题、所有博客的原md格式的文档、博客的配置信息)都是在scaffolds，source，themes和_config.yml中，所以只需要将这些文件维护到GitHub上，就可以随时随地在任何地方down下自己的环境文件，从而就可以开始你的创作了。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>在username.github.io仓库中新建一个hexo分支，用master分支来存放hexo发布的静态网页信息(即就是public目录下的内容)，用hexo分支来存放你的博客环境信息。其实当你执行完<code>hexo init</code>初始化命令后，你会发现hexo会默认帮你生成一个.gitignore文件，内容如下所示：</p><p><img src="./hexo_init_gitignore.png" alt="gitignore内容"></p><p>这里面已经自动帮你剔除了所有和hexo环境信息无关的目录了，所有你不做主动做任何过滤，直接在本地新建一个hexo分支，并将环境信息提交到GitHub对应的hexo分支即可。在博客根目录的_config.yml中指定deploy的branch为master分支即可。</p><h2 id="本地自测"><a href="#本地自测" class="headerlink" title="本地自测"></a>本地自测</h2><p>在本机新建一个文件夹，将username.github.io仓库的hexo分支clone到本地，然后执行<code>npm install</code>命令来安装所需要的相关相关依赖。<strong>切结不要执行<code>hexo init</code>命令</strong> ，因为该命令会初始化本地hexo环境，会用默认的hexo配置和主题来覆盖你自己的设置；因为我们hexo分支上的源码已经是自己当初所配置的环境，所以没必要初始化，只需要安装相关依赖，然后渲染自己的博客源文件<code>hexo g</code>,并在本地新开一个端口做测试<code>hexo s -p 5000</code>, 你会发现本地展示效果和通过username.github.io一致。至此已搞定全部问题。</p><p>需要注意的是，我这里是在本地做的测试。如果换台机器，保证已安装有git和node.js的前提下，按照上述再操作一遍即可。</p>]]></content>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
